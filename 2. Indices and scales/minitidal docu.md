Documentation on Mini Tidal patch \n

Originally,  I began by experimenting with the { , } operator to try and get a standard drumbeat going, with the bass drum and snare on one side of the {} operation, and the high hats on the other. Then I wanted to include some glitches and artifacts to the rhythm, so I created semi-random (as they would loop) instances of extremely fast repetitions to create glitchy pitches, making sure they happened rarely to conserve on server space. I also wanted to create instances of mutes where a beat would normally go, so I added mutes to the randomization, then decided to vastly increase the number of repetitive samples in each random bracket so that I could give weights to different sounds, for example making it 50% likely for a bd to play, 15% likely for a bd*2 to play, 30% likely for a mute, and 5% for a sudden glitch pitch. \n

Afterwards, I wanted to go more in-depth into the functions mini-tidal provided, so I went into the tutorial on the estuary website, where I found out that mini-tidal came with more than just bd and sn but also casio samples of bd and sn, etc, which made me then go onto the Tidalcycles website, where I found more samples, as well as functions, that I could use for my loop. I went through multiple iterations until I finally landed on my final code. One thing I found interesting was that, by not seperating the bd and sn from the hc and ho, I could add a "?" to strain the server (only slightly more, by 5%) with the first loop, creating a much more interesting drum loop.\n

stack [s "{[bd casio | bd casio | bd casio | bd | bd | bd*4 | ~ | ~ | bd | bd | bd | bd*2] ~ [sn | sn casio | sn casio | sd | sn casio | sd*5 | ~ | ~ | ~ | ~ | ~] ~ [bd | bd | bd | bd*5 | bd*2 | bd*3] ~ [sd | sn casio | sd | sn casio | sd | sd | sn casio | sd | sn casio | sd*6 | sn casio*999] , [hc | ho | hc | ho | hc | ho | hc | ho | hc*5 | ho*7 | ho*300] [ho | hc | ho | hc*3 | ho*3 | hc*5 | ho | hc | ho | hc] [hc | hc | ho | hc | ho | hc | ho | ho*251] [hc | ho | hc | ho | hc | ho | hc | ho | hc | ho | ho | hc | ho | hc*351] [hc | ho | hc | ho | hc | ho | hc | ho | hc | ho*613] [hc | ho | hc | ho | hc | ho | hc | ho | hc] [hc | ho | hc | ho | hc*2 | hc | ho | hc | ho | hc | ho | hc | ho*719 | ho*3 | hc*6 | ho*5 | hc*4] hc ho}" # gain 1,
s "rave" # note "[0 | 6 | 7 | 11 | -5 | -32 | 4 | 25 | -15 | 1 | 2 | 3 | 5 | 6]" # n (irand 5) # delay 0.9 # delaytime 1.5 # delayfeedback 0.5,
loopAt 1 $ every 5 (# vowel "a e i u a e o u a i o u o u o a a u o e i e a") $ s "arpy*18" # note "-24 -17 -15 -12 -7 -5 -2 0 4 7 11 12 10 11 12 15 -3" # pan sine # speed "[1 | 0.5 | 1.5 | 2]" # gain 1.5 # vowel "p" ,
s "industrial*14" # note "-22 -17 -15 -12 -5 -2 0 4 7 12 10 11 113 15 -4 ?" # pan sine # speed "[1 | 0.5 | 1.5 | 2]" # shape 0.9,
s "glitch" # n (irand 4) # shape 0.8]